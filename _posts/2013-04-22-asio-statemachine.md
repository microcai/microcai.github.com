---
layout: post
title: ASIO 与协程
---

前段时间看了 ASIO 爸爸关于ASIO的一个演讲. ASIO 爸爸说, ASIO 的设计理念就是作为一个 toolkit 而不是一个框架. ASIO并不强迫你使用某种编程模型. 它只是提供一系列的函数和类帮你更容易的编程.


ASIO 的设计思想其实和 GLIB 的 g_main_loop 非常像. 但是 C++ 因为有模板, 所以能更好的实现. 使用 g_main_loop 的时候, 我不记得我写了多少 void* 到 struct 的转化了. 这就是 C 的弊病. 因为缺少模板,所以回调必须严格符合函数签名. 但是库作者永远想不到用户还需要什么样的参数. 于是void*就是最好的解决办法了.

但是因为 C++ 有模板,所以放松了对函数签名的要求. 不符合 ASIO 回调函数签名要求的,都可以使用 bind 绑定以符合签名要求. 这就为库的使用者带来了巨大的灵活性的同时仍然保持极佳的易用性.

C++的另一个强大优势即是函数对象(bind的结果就是一个函数对象). 通过函数对象, 使得一些状态可以保存到成员变量中, 这样就给了我们一个不需要栈就实现的一个协程. 协程本质上是一个拥有多重入口和多重出口的函数. 每次调用都将从上一次退出的地方继续执行. 如果没有成员变量, 所有的变量都将保持于栈上, 这就要求协程的实现必定带来栈切换. 而栈的要求就导致协程必须有额外的创建和撤销动作. 这都给协程的实际使用造成了限制.

C++的函数对象, 既可以像普通函数那样调用, 又可以像通常的对象那样携带成员变量. 因此通过将变量置于对象而不是栈上, C++就可以实现无栈协程. 无栈协程的开销不过就是一个函数对象, 而无需一次性分配一个巨大的内存用于栈. 通常一个栈实现的协程,需要分配一个 1MB~10MB 的内存用于栈. 而无栈协程所使用的对象,不过就只是一个函数对象,通常大小不过几个字节到几百字节. 因此无栈协程允许创建大量的协程,而无需当心内存开销.

ASIO 爸爸即创造性的提出了无栈协程的概念, 然后将它用于实践中.

使用无栈协程, 伴随的ASIO的另一个重要用法: 复合回调函数. 将多个回调函数复合为一个. 多个ASIO操作使用同一个回调函数进行处理. 然后使用 Duff's Device 的方法自动构建状态机. 每次调用自动的从上一次退出的地方继续执行.

由于 ASIO 对于回调函数是执行的拷贝操作,因此用于 ASIO 协程的函数对象必须是可拷贝的. 实现这个其实也非常轻松, 即对于不能拷贝的成员变量使用 shared_ptr 封装即可.

每次使用 yield 发起异步操作的时候, 记住, 当前的对象会在退出函数的时候撤销. 但是于此同时, ASIO 也获得了对象的一份拷贝. 用于下次回调. 这个特性有时候可以被利用, 用于实现非常复杂的逻辑. avbot 的 RPC 实现即利用了这个特性. 将复杂的逻辑使用寥寥数行代码轻松实现.









