---
layout: post
title: TCP拥塞控制
---

BBR 为啥要对包的发送时机进行调度呢? 是为了防止缓存堆积.
比如对方的接收速率是  1MB/s . 你的本地发送速率可以达到  1.1GB/s . 
RTT = 500ms, 窗口大小是  500KB. 
好,  现在有  500KB 的数据要发送, 那么你是一次性发出呢? 还是把  500KB 分到 0.5s 的时间内匀速发出?
500KB 是  500 个包. 在 10Gbps 的本地链路上, 你只要 0.5ms 就全部发出去了.
而对方是 1MB/s 的速度, 所以需要  500ms 的时间接收.
这一速率不匹配, 是靠 中间设备的  "缓存" 来吸收的震荡.
在 BBR 出现前, 都是这么做的,  就是窗口大小的数据, 一股脑的全丢出去了.
靠链路上的各种交换机和路由器的缓存来吸收震荡.
但是 BBR 不这么干 .
BBR 认为, 既然带宽只有  1MB/s 而你的窗口 500KB, 要发 500KB 数据过去, 就是要把 500KB 均匀的铺到 1MB 里.

控制本地发送的频率.
哪怕你本地是 10Gbps 的网卡. 你也要把这 500KB 的数据个均摊到 500ms 的时间内发.
我认为 这是  BBR 对传统拥塞控制算法的最大改进.

这个改进在 BBR 里是通过算法同时输出 Pacing Rate 和 cwin 实现的.
BBR 对 Linux 的TCP栈的巨大改进之二是让拥塞控制算法彻底接管 TCP 状态机. Linux 的 TCP 拥塞控制实现里, 拥塞算法只用来探测增窗, 一但丢包减窗逻辑就被内建的 PRR 算法接管. 而 BBR 则改变了之前的做法, 拥塞算法不仅仅控制窗口大小, 也控制发送时机.
