---
layout: post
title: 内核TTY控制台的问题
---

最近因为编写TTY控制台的UNICODE字体支持补丁，拜读了控制台的代码，诶，妈呀，这个是什么代码哟 ......

TTY 控制台最开始的时候是使用 VGA 显卡的 TEXT模式的。 VGA TEXT 模式有个非常特别的地方就是，显存被映射到了一个固定的位置, 大约接近  1MB 的下方。 两个字节一对。第一个字节指示下一个字节的属性。第二个字节指示一个字符 index. 而这个字符表包含了 255 个字符，在 Windows 中， 这个字符集被称做 OEM codepage, 前127个字符和 ASCII 是一样的. 这样只要向对应的地址写入字符属性和字符的代码，就可以在对应的屏幕位置显示出对于的文字。这TTY 控制台就依据 VGA 字符模式写开了。每个 tty 终端都对应一个结构体。

这个结构体里有一个 vc_screenbuf 的成员，里面就是按照 VGA text 模式保存的整个屏幕的字符。切换终端的时候，就是一个 memcpy 把这个地方的字符拷贝到显存里，就完成了终端显示的切换。

问题就出在这里。vc_screenbuf 完全是依据 VGA Text 模式设置的。哪里有地方给你保存 UNICODE 编码啊，只有 255 个字符哦 ...... 

直接改成  32bit/32bit pair 不就行了？

NO~NO~NO~NO~

不行！ 因为完全和 TTY 无关的别的代码都已经按照现行的结构来写了，这样一改就会大动干戈, 改掉很多很多不是控制台部分的代码。而且，控制台其他部分的代码，也都是直接按照这种格式去操作的，完全没有用宏去封装，改起来难度非常大。

我曾经花了2天时间去做这种改动。修改了超过一千行代码 ... 结果 ... 还是改不动。
太多地方已经很顽固的假设这种布局了。

那么，把 字符和属性分开？ textbuf 和 attrbuf ? 其实就相当于重写。
我也花了2天时间这么搞 .. 结果 tty 部分的代码终于改好了，结果发现内核的很多其他部分也要修改 ... ... 

什么叫牵一发而动全身？这就是。

最后，我只得在老代码上缝缝补补，做了点小聪明似的 hack 来保证中文显示。

但是，我知道，这样的 hack 是绝对进不了官方内核的。我必须想想的办法，改掉这种被动的局面。 尽量低耦合。做到漂亮的 clean up。这样内核开发者才能接受。 

