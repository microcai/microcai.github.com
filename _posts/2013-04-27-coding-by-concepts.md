---
layout: post
title: 用概念编程
---

C++ 爸爸对 c++11 提出了一个 “模板概念” 提案，可是又亲自否决了它。因为他觉得还不够好，还要继续研究一番才行。C++是一个严谨的语言，新特性的加入要小心谨慎。

虽然提案没有通过，但是，C++爸爸俨然已经将那个 C with Class 的语言进化了，C++不再是一个 C with Class 的语言，而是迈出了“概念”编程的一步。

概念编程在C++中由来已久，C++爸爸的提案就是为了在语言级更好的支持概念编程。在语言没有支持到家的时候，通过修修补补，也还是能将就使用。

什么是用概念编程呢？ 简单的来说，就是弱化类型，强调概念。比如 std::sort , 它的参数是什么呢？ 他的参数可以是任何一种迭代器所表示的区间。任何类型的迭代器都可以。不论是指向int的还是string的还是你自己定义的类。这就是 std::sort 所需要的参数的概念。因为在人脑中，对一样东西排序可不需要知道他是数组还是链表。std::sort 对于 迭代器指向的对象也有一个要求：必须能比较大小。不能比较大小的东西还能排序么？

那么这就是 std::sort 所提出的概念要求。以概念编程，就越来越接近人脑的思维。人不再需要将抽象的概念具像为C语言中的基本类型。

前段时间我写的 [boost 编码 base64](/2013/03/28/boost-base64.html) 也是概念编程的产物。因为你不用再幸苦的思索base64的编码算法了。只要依据 base64 的描述就可以写出编解码的代码了。

根据base64概念，编码过程就是 6bit 为一个单位，然后转化为 ASCII 字符。那么就简单了，你需要一个将输入流转化为6bit的迭代器。也就是 boost::archive::iterators::transform_width 这个迭代器，模板参数区分别是 6, 8, char。接着你获得了 6bit 的数据，然后通过base64_from_binary这个迭代器输入6bit数据输出ASCII编码。

将迭代器嵌套起来，就就获得了一个 base64 编码器了。 base64_from_binary<transform_width<6,8,char> > 就是一个 base64 编码的迭代器了。输入二进制数据，输出base64编码的数据。有使用 ，你还需要每78个字符换行，那么简单到再嵌入一个 boost::archive::iterators::insert_linebreaks 就可以自动的插入换行符了！

同样的，一个 base64 解码器也非常简单，首先是一个 boost::archive::iterators::remove_whitespace 迭代器，移除空白字符，如那个每78字符换行，然后是 boost::archive::iterators::binary_from_base64 从 ASCII 生成 6bit数据，接着是 boost::archive::iterators::transform_width 和编码反过来，模板参数为 <8, 6, char> 将6bit输入拼成8bit输出。

看，只要使用概念就可以完成编程了！ 千万不要当心效率问题，编译器能将这种多重间接的迭代器访问给优化为单个指针访问。不要低估编译器的优化能力。
